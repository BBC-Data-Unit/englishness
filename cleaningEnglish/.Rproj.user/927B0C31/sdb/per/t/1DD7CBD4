{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Cleaning the YouGov Englishness survey\"\noutput: html_document\n---\n\n# Cleaning the YouGov Englishness survey\n\nThe data comes in an Excel workbook with the main data on the third sheet. This needs to be placed in the same folder as this code.\n\n```{r, eval=FALSE, include=FALSE}\n#This code chunk is set not to run because it's already been installed. However, if you get an error regarding rio below, you may want to install it by running the code here.\n#Install rio to make importing easier\ninstall.packages(\"rio\")\n```\n\n\n```{r}\n#change this to new file name before running\nfilename <- \"englishnessmarch18v2.xls\"\n#activate rio library\nlibrary(rio)\n#import the third sheet of that filename\nresultsdirty <- import(filename,sheet=3)\n```\n\n## Stripping out empty/unneeded rows\n\nWe need to create a new data frame to contain our work in progress. We'll store the first proper row of data (row 6) to make sure it has the right number of fields. Then we'll set the column names to those in row 5.\n\n```{r}\n#Create a new data frame from all but the first 5 rows of the dirty data\nresultscleaning <- resultsdirty[-(1:5),]\n#Grab 5th row with headings and use as column names\ncolnames(resultscleaning) <- resultsdirty[5,]\n\n#You could use these lines if you want to combine both header rows\ncolumnnamesmerged <- paste(resultsdirty[4,],resultsdirty[5,])\n#Then replace the NAs where one of the two cells being combined was empty\ncolumnnamesmerged <- gsub('NA','',columnnamesmerged)\n```\n\n## Transposing\n\nThere are a number of ways of transposing a data frame in R. The `reshape` package's `t` function is just one.\n\n```{r, eval=FALSE, include=FALSE}\n#Install reshape package - this code block doesn't run by default as it's now been installed\ninstall.packages(\"reshape\")\n```\n\nLet's use it... \n\n```{r}\n#Add to library\nlibrary(reshape)\n#Use t function to transpose cleaned data \ntransposeresults <- t(resultscleaning)\ntransposeresults.bymatrix <- as.data.frame(t(as.matrix(resultscleaning)))\n#This doesn't have column headings yet, so we can extract those from the other's first row\n#However, many of the entries here are identical, which makes extracting columns hard\ncolnames(transposeresults.bymatrix) <- transposeresults[1,]\n#And remove our now redundant first row\ntransposeresults.bymatrix <- transposeresults.bymatrix[-1,]\n#This way has a similar result but missing the first column\nlibrary(data.table)\ntransposeresults.datatable <- transpose(resultscleaning)\n```\n\n## Extracting just the counties\n\nA new data frame can be created by extracting specific rows\n\n```{r}\n#The 6th column contains the answer to % who feel very strongly English\nverystrongenglish <- as.data.frame(transposeresults.bymatrix[,7])\n#Add the row names so we know what they match to\nverystrongenglish$subcategory <- rownames(transposeresults.bymatrix)\n```\n\nWe can access a particular row by using its name instead of an index, like so:\n\n```{r}\ntransposeresults.bymatrix[\"Con\",]\n```\n\nAnd we can find out the index of a row by using `which` like so:\n\n```{r}\nwhich(rownames(transposeresults.bymatrix)==\"No county\")\n```\n\nBecause we know counties begin at index 34 we can chop out the others:\n\n```{r}\nresultsplacesonly <- transposeresults.bymatrix[-(1:33),]\n```\n\nLikewise we can extract just those results related to age by first identifying the indexes...\n\n```{r}\nwhich(rownames(transposeresults.bymatrix)==\"18-24\")\nwhich(rownames(transposeresults.bymatrix)==\"65+\")\n```\n...and then extracting those:\n\n```{r}\nresultsagesonly <- transposeresults.bymatrix[(9:12),]\n```\n\n\n\n## Export as CSV\n\n\n```{r}\nwrite.csv(resultsplacesonly,\"resultslocationsonly.csv\")\nwrite.csv(resultsagesonly,\"resultsagesonly.csv\")\n```\n\n\n## Narrow down further\n\nAnd if we only want answers to one particular question we can do the same for columns:\n\n```{r}\n#First find out the headings and indexes\ncolnames(resultsplacesonly)\n#Then only grab those we want - the Englishness/Britishness questions run up to row 21\nenglishbritishnessonly <- resultsplacesonly[,c(1:2,5:21)]\n```\n\n\n\n## Cleaning column names\n\nCould we make the column names clearer? Because the question and the answers are in separate rows in the original spreadsheet - and these are now columns in the transposed versino - it's not easy to see the answer in context. The code below pulls the question into each answer in parentheses to address this.\n\n```{r}\n#Change columns 5-11 to add 4 \"(English)\" in parentheses\ncolnames(englishbritishnessonly)[5:11] <- paste(\n  colnames(englishbritishnessonly)[5:11],\n  \" (\",\n  colnames(englishbritishnessonly)[4],\n  \")\",sep=\"\"\n  )\n#show the column names\ncolnames(englishbritishnessonly)[13:19]\n#Change columns 5-11 to add 4 \"(English)\" in parentheses\ncolnames(englishbritishnessonly)[13:19] <- paste(\n  colnames(englishbritishnessonly)[13:19],\n  \" (\",\n  colnames(englishbritishnessonly)[12],\n  \")\",sep=\"\"\n  )\n#show the column names\ncolnames(englishbritishnessonly)[13:19]\n```\n\n\nNow export:\n\n```{r}\nwrite.csv(englishbritishnessonly,\"englishbritishnessonly.csv\")\n```\n\n## Creating a column name cleaning function\n\nBecause that pattern recurs - grabbing the question and inserting it into 7 answers that follow it - we should store it in a function to reuse.\n\n```{r}\n#dfname is the name of the data frame to be cleaned\n#questioncolumnindex should be the index of the column containing the question to be added to answers (this should come just before them)\ncleancols <- function(dfname,questioncolumnindex){\n  #create a range which starts at a number one higher than the question index, and ends 7 higher\n  answerrange <- seq(questioncolumnindex+1,questioncolumnindex+7)\n  print(answerrange)\n  #replace the column names with the same column names, but adding the question at the index specified, between brackets\n  colnames(dfname)[answerrange] <- paste(\n  colnames(dfname)[answerrange],\n  \" (\",\n  colnames(dfname)[questioncolumnindex],\n  \")\",sep=\"\"\n  )\n#colnames(dfname)[answerrange]\n#send the results back to whatever called this function\nreturn(dfname)\n}\n```\n\nAnd test that:\n\n```{r}\n#Create the unclean version as before\nenglishbritishnessonly.test <- resultsplacesonly[,c(1:2,5:21)]\n#Run the function with that, and an index of 4\nenglishbritishnessonly.test <- cleancols(englishbritishnessonly.test,4)\n#Trying it again creates an error\nenglishbritishnessonly.test <- cleancols(englishbritishnessonly.test,12)\n```\n\nThe function has also been saved as an R file called cleancols7.R\n\n## Creating subsets for particular questions\n\nEach section below generates a dataset to address one of the following bullet points:\n\n* The most/least English pieces. What the data tells us about the split between regions, old and young etc.\n* Feature: Embarrassed to be English? Exploring one of the questions from the survey\n* Feature: Who rules us? Combined authorities were brought in to give super regions are bigger say in their own affairs. People are said to like them and yet they are held largely behind closed doors. Are these better than an English parliament? \n* And has that idea now gone away?\n\n### Creating a data frame for all 'Do you identify yourself as being' questions\n\n\nThe answers down to row 76 on the original xls file all relate to this question. Here we grab all those and put into one data frame, then export.\n\n```{r}\n#First find out the headings and indexes - limit to the first 100\nhead(colnames(resultsplacesonly),100)\n#Then only grab those we want - the questions run up to row 69 (we leave out columns 3 and 4 because they are blank)\nidentificationonly <- resultsplacesonly[,c(1:2,5:69)]\n#repeat with the ages only data frame\nidentificationonly.ages <- resultsagesonly[,c(1:2,5:69)]\n```\n\nThe questions we want run up to index 69 - this is 6 before the row 75 which we know is where the break appears in the spreadsheet, and we removed 6 rows, so we can use this knowledge to identify indexes in future.\n\nNow to clean the column headings using that function.\n\n```{r}\n#First create a sequence that starts with the index for the first question, and stores every 8th index, e.g. 4, 12, and so on.\nquestioncols <- seq(4,length(identificationonly),8)\n#This is then used to loop through and create a clean dataset\n#First, create a new data frame to use for cleaning so we can compare\nidentificationonly.clean <- identificationonly\nfor (i in questioncols){\n  identificationonly.clean <- cleancols(identificationonly.clean,i)\n}\n```\n\nNow to repeat for ages\n\n```{r}\n#First create a sequence that starts with the index for the first question, and stores every 8th index, e.g. 4, 12, and so on.\nquestioncols <- seq(4,length(identificationonly.ages),8)\n#This is then used to loop through and create a clean dataset\n#First, create a new data frame to use for cleaning so we can compare\nidentificationonly.ages.clean <- identificationonly.ages\nfor (i in questioncols){\n  identificationonly.ages.clean <- cleancols(identificationonly.ages.clean,i)\n}\n```\n\nAnd export:\n\n```{r}\nwrite.csv(identificationonly.clean, \"identificationonly_areas.csv\")\nwrite.csv(identificationonly.ages.clean, \"identificationonly_ages.csv\")\n```\n\n### Extracting 'How do you think of yourself?'\n\nThis question appears in row 77 of the spreadsheet: 'Which of the following best describes the way you think of yourself?'\n\n\n```{r}\n#Then only grab those we want - the questions run up to row 69 (we leave out columns 3 and 4 because they are blank)\nthinkofonly <- resultsplacesonly[,c(1:2,71:80)]\n#repeat with the ages only data frame\nthinkofonly.ages <- resultsagesonly[,c(1:2,71:80)]\n```\n\nThere's no need to add extra detail to column headings as this is so small.\n\n```{r}\nwrite.csv(thinkofonly, \"thinkofonly.csv\")\nwrite.csv(thinkofonly.ages, \"thinkofonlyages.csv\")\n```\n\n### Extracting 'embarrassed'\n\nThis question appears in row 88 of the spreadsheet: 'Which of the following best describes the way you think of yourself?'\n\n\n```{r}\n#Then only grab those we want - the questions run up to row 69 (we leave out columns 3 and 4 because they are blank)\nembarrasedonly <- resultsplacesonly[,c(1:2,82:91)]\n#repeat with the ages only data frame\nembarrasedonly.ages <- resultsagesonly[,c(1:2,82:91)]\n```\n\nThere's no need to add extra detail to column headings as this is so small.\n\n```{r}\nwrite.csv(embarrasedonly, \"embarrasedonly.csv\")\nwrite.csv(embarrasedonly.ages, \"embarrasedonlyages.csv\")\n\n```\n\n### Extracting combined authority questions\n\n\nRow 601 onwards of the spreadsheet relate to combined authorities and other authorities.\n\n\n```{r}\n#Then only grab those we want - the questions run up to row 69 (we leave out columns 3 and 4 because they are blank)\nclaonly <- resultsplacesonly[,c(1:2,595:649)]\n#repeat with the ages only data frame\nclaonly.ages <- resultsagesonly[,c(1:2,595:649)]\n```\n\nWe need to inject questions into answers again. This time it's one for every 4, so let's adapt the previous function:\n\n```{r}\n#dfname is the name of the data frame to be cleaned\n#questioncolumnindex should be the index of the column containing the question to be added to answers (this should come just before them)\ncleancols4 <- function(dfname,questioncolumnindex){\n  #create a range which starts at a number one higher than the question index, and ends 4 higher\n  answerrange <- seq(questioncolumnindex+1,questioncolumnindex+4)\n  print(answerrange)\n  #replace the column names with the same column names, but adding the question at the index specified, between brackets\n  colnames(dfname)[answerrange] <- paste(\n  colnames(dfname)[answerrange],\n  \" (\",\n  colnames(dfname)[questioncolumnindex],\n  \")\",sep=\"\"\n  )\n#colnames(dfname)[answerrange]\n#send the results back to whatever called this function\nreturn(dfname)\n}\n```\n\nNow to clean the column headings using that function.\n\n```{r}\n#First create a sequence that starts with the index for the 13th question, and stores every 5th index, e.g. 13, 18, and so on.\nquestioncols5 <- seq(13,length(claonly),5)\n#This is then used to loop through and create a clean dataset\n#First, create a new data frame to use for cleaning so we can compare\nclaonly.clean <- claonly\nfor (i in questioncols5){\n  claonly.clean <- cleancols4(claonly.clean,i)\n}\n```\n\nNow to repeat for ages:\n\n```{r}\n#First create a sequence that starts with the index for the 13th question, and stores every 5th index, e.g. 13, 18, and so on.\nquestioncols5 <- seq(13,length(claonly),5)\n#This is then used to loop through and create a clean dataset\n#First, create a new data frame to use for cleaning so we can compare\nclaonly.ages.clean <- claonly.ages\nfor (i in questioncols5){\n  claonly.ages.clean <- cleancols4(claonly.ages.clean,i)\n}\n```\n\n\nAnd export.\n\n```{r}\nwrite.csv(claonly.ages.clean, \"claonly_ages.csv\")\nwrite.csv(claonly.clean, \"claonly.csv\")\n\n```\n\n\n\n\n### Extracting English parliament questions\n\nThis question appears in row 580 of the spreadsheet: 'Would you support or oppose introducing an English Parliament, similar to the Welsh Assembly or Scottish Parliament?'\n\n\n```{r}\n#Then only grab those we want - the questions run up to row 69 (we leave out columns 3 and 4 because they are blank)\nengparliament <- resultsplacesonly[,c(1:2,574:581)]\n#repeat with the ages only data frame\nengparliament.ages <- resultsagesonly[,c(1:2,574:581)]\n```\n\nThere's no need to add extra detail to column headings as this is so small.\n\n```{r}\nwrite.csv(engparliament, \"engparliament.csv\")\nwrite.csv(engparliament.ages, \"engparliament_ages.csv\")\n```\n\n",
    "created" : 1525255715265.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "87322947",
    "id" : "1DD7CBD4",
    "lastKnownWriteTime" : 1525789982,
    "last_content_update" : 1525789982,
    "path" : "~/Documents/GitHub/Rintro/cleaning/cleaningEnglish/cleaningenglish.Rmd",
    "project_path" : "cleaningenglish.Rmd",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}